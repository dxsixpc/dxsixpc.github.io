## 函数中变量的作用域

```
概念：什么是作用域，变量在函数内部作用的范围／区域。有函数的地方就有作用域
		生效的区域，可以被使用的区域
		变量和函数
function fn(){
        var a = 1;
    }
    console.log(a);    //报错：a is not defined
    用var声明的变量，实际上是有作用域的
    在函数内部定义的变量，该变量的作用域是整个函数体，在函数体外不可引用该变量，这是局部作用域

    变量的生命周期：
    1.永远存在－－－－全局
        程序没关，一直占用内存，少用全局
    
    2.朝生暮死－－－－局部
        函数的大括号开头到函数的大括号结尾

    var a = 1;
    function fn(){
        console.log(a);    //1
    }
    console.log(a);    //1
    不在任何函数内定义的变量就具有全局作用域。全局变量在任何地方都能调用。

利用匿名函数生成一个局部作用，把变量的声明和使用这个变量的小函数都放在匿名函数中

    扩展：javascript默认有个全局对象window，全局作用域的变量实际上被绑定到window的一个属性

	作用域分类：
		全局作用域：整个代码空间，就是全局
		局部作用域：只要是函数，那么函数内部就是局部作用域
		区别：
			全局不能使用局部
				若全局变量和局部变量重名，在局部作用域内，局部变量会覆盖全局变量
			局部可以使用全局
		函数的形参，相当于当前所属函数的局部变量
		如果在当前作用域中，没有找到要使用的变量，那么会自动向上级作用域查找，。。。还是没有报错
		变量的生命周期：
			全局变量：一直存在，跟随程序的结束而结束
			局部变量：只在作用域中存在，朝生暮死，作用域开始的位置被声明，结束的位置被删除
		优缺点：
			全局相对于局部，方便，但一直存在于内存中，占用资源。
			全局比局部要消耗性能，要尽量少用或不用全局，及其容易造成变量命名的重复
		折中方法：
			将所有函数写在匿名函数内，当做一个大的局部变量写
			语法：
				(function(){
					
				})();
```

## 函数中变量的声明提升：

```
变量声明提升：

     console.log(a)     //undefined已经声明但是未赋值
     var  a = 2;
     console.log(a)     //2

     consoleo.log(b)     //not a defined未声明
    

    function fn(){
        console.log(a)    //undefined
        var a = 1;
    }
    fn();
    在函数fn()中，在没有定义变量之前打印a，得到undefined，而并不是not defined
    说明此时变量已经被声明，只是还没有被赋值。

    上面的fn()函数可以理解成
    function fn(){
        var a;
        console.log(a);
        a = 1;
    }
    fn();


    我们称这种现象为变量的声明提升，所有使用var声明的变量会在当前作用域最开始的部分被声明。   

    函数的声明提升：整体提升
    fn();        //2
    function fn(){
        console.log(2);
    }
    fn();        //2

------------------------------------

    console.log(fn);     //undefined
    fn();                //not a function
    var fn = function(){
        console.log(1);
    }

var 提升
		提前声明，原处赋值
		提升到作用域一开始的位置，（逻辑上抽象的位置，并不是眼睛看到的第一行）
	funvtion 提升
		整体提升
	赋值式创建函数，提升的是变量，不是函数
		var 声明的变量和function声明的函数重名了，function生效
		var更高，有可能被覆盖
		js的编译和执行
		先检查语法错误－－－语法错误，当前代码段不执行
    声明提升－－－－－－变量提升和函数提升，作用域内所有使用var声明的变量和非匿名函数
    开始编译－－－－－－逐行执行
    函数声明提升：
    fn();                    //1
    function fn(){
        console.log(123);
    }
    
    但是：
    fn();                    //报错：fn is not a function
    var fn = function(){
        console.log(123);
    }
    以上写法等于：
    var fn;                  //此时声明变量fn，未定型和存值
    fn();                    //所以此时的fn不是一个函数，不能使用执行函数的方式执行，强行执行会报错
    fn = function(){         //此时才对fn赋值函数
        console.log(123);
    }
    fn();                    //这时就可以执行了
```





## 



## 	